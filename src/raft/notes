Notes:

1>
log is atleast as up-to-date as receiver’s log, grant vote
Raft determines which of two logs is more up-to-date by comparing the index and term of
the last entries in the logs. If the logs have last entries with different terms,
then the log with the later term is more up-to-date. If the logs end with the same term,
then whichever log is longer is more up-to-date.

2>
what about a leader stepping down in append entries call?, the argument here could be that, if there is a leader
who was isolated and rejoined the network, it would step-down, when it sends its append entry and
realizes that it is no longer the up to date leader
Not required to check for a leader if it has step down in append entries

3>
// have we already voted for another peer in request's term?
// If votedFor is empty or candidateId, then grant vote
// where votedFor => candidateId that received vote in current term (or null if none)
// who did we vote for in the term?

4> This has to be done for apply to state machine:
If commitIndex > lastApplied: increment lastApplied, apply log[lastApplied] to state machine (§5.3)

5>
If successful: update nextIndex and matchIndex for follower (§5.3)
If AppendEntries fails because of log inconsistency: decrement nextIndex and retry (§5.3)
If there exists an N such that N > commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm: set commitIndex = N (§5.3, §5.4).
